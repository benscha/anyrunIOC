<#
.SYNOPSIS
Automates the collection of Indicators of Compromise (IOCs) from ANY.RUN Malware Trends and imports them as a Watchlist into Azure Sentinel.

.DESCRIPTION
This PowerShell Runbook is designed for execution in Azure Automation. It performs the following steps:
1.  Connects to the ANY.RUN Malware Trends page and identifies links to current malware analyses.
2.  Parses each analysis page to extract IOCs (IPs, Hashes, Domains, URLs) and associated metadata (Malware Name, Type, Origin, Seen dates) using web scraping and regular expressions.
3.  Structures the collected data and temporarily exports it as a CSV file (and optionally JSON) to the $env:TEMP path of the Automation Sandbox.
4.  Authenticates to Azure using the Automation Account's Managed Identity.
5.  Imports the generated CSV file into the configured Azure Sentinel/Log Analytics Workspace as a Watchlist named 'AnyrunIOC', using the 'SentinelEnrichment' module and replacing any existing list.

.PARAMETER SubscriptionId
The ID of the Azure subscription where the Sentinel Workspace resides.

.PARAMETER ResourceGroupName
The name of the Azure resource group containing the Sentinel Workspace.

.PARAMETER WorkSpaceName
The name of the Azure Log Analytics Workspace where Azure Sentinel is enabled.

.PARAMETER WatchListName
The name of the Watchlist to be created or updated in Sentinel (Default: AnyrunIOC).

.PARAMETER SearchKey
Defines the primary column in the Watchlist used for search operations (Default: IOCValue).

.NOTES
Author: Benjamin Zulliger
Version: 1.0
Date: October 2025
Requires: The Azure 'Az' module and the 'SentinelEnrichment' module in the Automation Account.
Permissions: The Managed Identity must have the 'Azure Sentinel Contributor' role on the Sentinel Workspace.
#>

# VARIABLE
param(
    [Parameter(Mandatory=$false)]
    [string]$SubscriptionId = "YOUR-SUBSCRIPTIONID",

    [Parameter(Mandatory=$false)]
    [string]$ResourceGroupName = "YOUR-RESOURCEGROUPNAME",

    [Parameter(Mandatory=$false)]
    [string]$WorkSpaceName = "YOUR-WORKSPACENAME",

    [Parameter(Mandatory=$false)]
    [string]$WatchListName = "AnyrunIOC",
    
    [Parameter(Mandatory=$false)]
    [string]$SearchKey = "IOCValue"
)

$ErrorActionPreference = "Stop"
$SearchKey = "IOCValue"

# VARIABLE
param(
    [Parameter(Mandatory=$false)]
    [string]$SubscriptionId = "YOUR-SUBSCRIPTIONID",

    [Parameter(Mandatory=$false)]
    [string]$ResourceGroupName = "YOUR-RESOURCEGROUPNAME",

    [Parameter(Mandatory=$false)]
    [string]$WorkSpaceName = "YOUR-WORKSPACENAME",

    [Parameter(Mandatory=$false)]
    [string]$WatchListName = "AnyrunIOC",
    
    [Parameter(Mandatory=$false)]
    [string]$SearchKey = "IOCValue"
)

try {
    $exports ="$env:TEMP"
    $exportfile = "$exports\anyrun_iocs.csv"
    # ==============================
    # ANY.RUN IOC Scraper with CSV/JSON Export Options
    # ==============================

    # üîß Configuration
    $exportCsv = $true     # Enable/disable CSV export
    $exportJson = $false     # Enable/disable JSON export

    # Check if at least one export option is enabled
    if (-not ($exportCsv -or $exportJson)) {
        Write-Host "No export option enabled! Please set at least one variable (`$exportCsv` or `$exportJson`) to `$true`." -ForegroundColor Red
        exit
    }

    # ==============================
    # Main Routine
    # ==============================
    $anyrunURLs = (Invoke-WebRequest -UseBasicParsing -Uri "https://any.run/malware-trends/").Links |
    Where-Object { $_.href -like "/malware-trends/*" } |
    Select-Object href

    $staticURLPart = "https://any.run"
    $csvData = @()

    ForEach ($url in $anyrunURLs.href) {

        Write-Host "Processing URL: $url" -ForegroundColor White
     
        # Get the content of the trend page
        $content = Invoke-WebRequest -UseBasicParsing -Uri "$staticURLPart$url"
        $htmlContent = $content.Content

        # Reset variables for each page
        $malwareType = $null
        $malwareName = $null
        $origin = $null
        $firstSeen = $null
        $lastSeen = $null

        # Extract malware name
        $namePattern = '<h1 class="title dot-(?:success|warning|danger)">(.*?)</h1>'
        if ($htmlContent -match $namePattern) { $malwareName = $Matches[1].Trim() } 

        # Extract malware type
        $typePattern = '<i class="fas fa-puzzle-piece"></i>\s*(.*?)\s*</div>'
        if ($htmlContent -match $typePattern) { $malwareType = $Matches[1].Trim() } 
     
        # Extract origin (country)
        $originPattern = '<i class="fas fa-map-marker-alt"></i>\s*(.*?)\s*</div>'
        if ($htmlContent -match $originPattern) { $origin = $Matches[1].Trim() }

        # Extract and convert "First Seen" date
        $firstSeenPattern = '<i class="fas fa-calendar-alt"></i>\s*(.*?)\s*</div>'
        if ($htmlContent -match $firstSeenPattern) {
            $dateString = $Matches[1].Trim()
            $inputFormat = "d MMMM, yyyy"
            $culture = [System.Globalization.CultureInfo]::GetCultureInfo('en-US') 
            $outputFormat = "dd.MM.yyyy"
            try {
                $dateObject = [datetime]::ParseExact($dateString, $inputFormat, $culture)
                $firstSeen = $dateObject.ToString($outputFormat)
            }
            catch { $firstSeen = $dateString }
        }

        # Extract and convert "Last Seen" date
        $lastSeenPattern = '<i class="fas fa-clock"></i>\s*(.*?)\s*</div>'
        if ($htmlContent -match $lastSeenPattern) {
            $dateString = $Matches[1].Trim()
            $inputFormat = "d MMMM, yyyy"
            $culture = [System.Globalization.CultureInfo]::GetCultureInfo('en-US') 
            $outputFormat = "dd.MM.yyyy"
            try {
                $dateObject = [datetime]::ParseExact($dateString, $inputFormat, $culture)
                $lastSeen = $dateObject.ToString($outputFormat)
            }
            catch { $lastSeen = $dateString }
        }

        # Collect IOC data
        $currentIpData = @()
        $currentHashData = @()
        $currentDomainData = @()
        $currentUrlData = @()
        $DataName = ""

        ForEach ($Line in $htmlContent -split "`n") { 
            If ($Line -like "*ipData*") { $DataName = "ipData" } 
            ElseIf ($Line -like "*hashData*") { $DataName = "hashData" } 
            ElseIf ($Line -like "*domainData*") { $DataName = "domainData" } 
            ElseIf ($Line -like "*urlData*") { $DataName = "urlData" } 
            ElseIf ($Line -like "*list__item*") { 
                $DataValue = $Line.Replace('<div class="list__item">', '').Replace('</div>', '').Trim() 
             
                if ($DataValue -notin @("No IP addresses found", "No hashes found", "No Domain found", "No URLs found")) {
                    switch ($DataName) { 
                        "ipData" { $currentIpData += $DataValue } 
                        "hashData" { $currentHashData += $DataValue } 
                        "domainData" { $currentDomainData += $DataValue } 
                        "urlData" { $currentUrlData += $DataValue.Replace("http://", "").Replace("https://", "") }
                    }
                }
            } 
        } 
     
        # Build structured data for CSV/JSON
        $iocCollections = @{
            "ip"     = $currentIpData
            "hash"   = $currentHashData
            "domain" = $currentDomainData
            "url"    = $currentUrlData
        }

        foreach ($iocType in $iocCollections.Keys) {
            foreach ($iocValue in $iocCollections[$iocType]) {
                $csvData += [PSCustomObject]@{
                    'IOCType'      = $iocType
                    'IOCValue'     = $iocValue
                    'MalwareName' = $malwareName
                    'MalwareType'  = $malwareType
                    'Origin'       = $origin
                    'FirstSeen'    = $firstSeen
                    'LastSeen'     = $lastSeen
                }
            }
        }
     
        Write-Host "Processed: $url. Total IOCs collected so far: $($csvData.Count)"
    }

    # ==============================
    # Export Logic
    # ==============================

    if ($exportCsv) {
        $exportCsvPath = $exportfile 
        $csvData | Export-Csv -Path $exportCsvPath -NoTypeInformation -Encoding UTF8
        Write-Host "üìÅ CSV exported to: $exportCsvPath" -ForegroundColor Cyan
    }

    if ($exportJson) {
        $exportJsonPath = Join-Path $exports "anyrun_iocs.json"
        $csvData | ConvertTo-Json -Depth 5 | Out-File -FilePath $exportJsonPath -Encoding UTF8
        Write-Host "üìÅ JSON exported to: $exportJsonPath" -ForegroundColor Cyan
    }

    Write-Host ""
    Write-Host "Data export completed." -ForegroundColor Green
    Write-Host "Total number of exported IOCs: $($csvData.Count)" -ForegroundColor Green


    # Import Module SentinelEnrichment
    Import-Module -Name SentinelEnrichment
    
    # Connect to Auzre
    Connect-AzAccount -Identity

    # Write Watchlist
    New-GkSeAzSentinelWatchlist -SubscriptionId $SubscriptionId -ResourceGroupName $ResourceGroupName -WorkSpaceName $WorkSpaceName -WatchListFilePath $exportfile -WatchListName $WatchListName -ReplaceExistingWatchlist $true -SearchKey $SearchKey -Verbose

}


catch {
    $e = $_.Exception
    $line = $_.InvocationInfo.ScriptLineNumber
    $msg = $e.Message 
    Write-output "Error in Execution: $msg on line $line with $e" 
    throw "Error in Execution: $msg on line $line with $e" 
}
finally {
    Write-output "Done! WatchList $WatchListName created" 
}

